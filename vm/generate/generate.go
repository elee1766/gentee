// +build ignore

// Copyright 2019 Alexey Krivonogov. All rights reserved.
// Use of this source code is governed by a MIT license
// that can be found in the LICENSE file.

// This program generates stdlib.go. It can be invoked by running
// go generate

package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"regexp"
	"strings"
	"time"

	"github.com/gentee/gentee/core"
)

func str2type(in string) (ret string) {
	switch in {
	case ``:
		ret = `core.TYPENONE`
	case `int`, `thread`:
		ret = `core.TYPEINT`
	case `bool`:
		ret = `core.TYPEBOOL`
	case `float`:
		ret = `core.TYPEFLOAT`
	case `char`:
		ret = `core.TYPECHAR`
	case `str`:
		ret = `core.TYPESTR`
	case `range`:
		ret = `core.TYPERANGE`
	case `buf`:
		ret = `core.TYPEBUF`
	case `file`:
		ret = `core.TYPEFILE`
	case `fn`:
		ret = `core.TYPEFUNC`
	case `error`:
		ret = `core.TYPEERROR`
	case `set`:
		ret = `core.TYPESET`
	case `obj`:
		ret = `core.TYPEOBJ`
	default:
		if in == `arr` || strings.HasPrefix(in, `arr.`) {
			ret = `core.TYPEARR`
		} else if in == `map` || strings.HasPrefix(in, `map.`) {
			ret = `core.TYPEMAP`
		} else {
			ret = `core.TYPESTRUCT`
		}
	}
	return
}

func str2pars(in string) string {
	if len(in) == 0 {
		return `nil`
	}
	var types []string
	for _, par := range strings.Split(in, `,`) {
		types = append(types, str2type(strings.TrimSpace(par)))
	}
	return `[]uint16{` + strings.Join(types, `,`) + `}`
}

func main() {
	var (
		input    []byte
		out, crc string
		err      error
	)
	out = fmt.Sprintf(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by github.com/gentee/gentee/vm/generate/generate.go at
// %v

package vm

import "github.com/gentee/gentee/core"

var CRCStdlib uint64
var CRCCustom uint64
var EmbedFuncs = []core.Embed{
`, time.Now().Format("2006/01/02 15:04:05 MST"))

	if input, err = ioutil.ReadFile(`generate/stdlib.txt`); err != nil {
		log.Fatal(err)
	}
	re, err := regexp.Compile(`^([\wยบ]+)\(([\w ,\.\*]*)\)\s*([\w\.\*]*);([ยบ\w]+);?(\w*)?`)
	if err != nil {
		log.Fatal(err)
	}
	var count int64
	for i, v := range strings.Split(string(input), "\n") {
		var (
			embed     core.Embed
			code, fnc string
		)
		v = strings.ReplaceAll(v, ` `, ``)
		if len(v) == 0 {
			continue
		}
		count++
		crc += v
		list := re.FindAllStringSubmatch(v, -1)
		vals := list[0]
		if strings.ToUpper(vals[4]) != vals[4] {
			code = fmt.Sprint(i)
			fnc = vals[4]
			if strings.HasPrefix(fnc, `Assign`) {
				assignType := `Any`
				if strings.HasPrefix(vals[2], `int`) {
					assignType = `Int`
				} else if strings.HasPrefix(vals[2], `float`) {
					assignType = `Float`
				} else if strings.HasPrefix(vals[2], `str`) {
					assignType = `Str`
				}
				fnc = fmt.Sprintf(`core.Assign%sFunc(%s)`, assignType, fnc)
			}
		} else {
			fnc = "nil"
			if vals[4] == `LEN` {
				code = fmt.Sprintf(`%s<<16 | core.LEN`, str2type(vals[2]))
			} else {
				code = "core." + vals[4]
			}
		}
		embed.Variadic = strings.Contains(vals[5], `v`)
		embed.Runtime = strings.Contains(vals[5], `r`)
		embed.CanError = strings.Contains(vals[5], `e`)
		out += fmt.Sprintf(`	{Name: "%s", Pars: "%s", Ret: "%s", Code: %s, 
		Func: %s, Return: %s, 
		Params: %s, 
		Variadic: %v, Runtime: %v, CanError: %v},
`, vals[1], vals[2], vals[3], code, fnc, str2type(vals[3]), str2pars(vals[2]),
			embed.Variadic, embed.Runtime, embed.CanError)
	}
	out += fmt.Sprintf(`}
const StdLibCount = %d
`, count)
	if err = ioutil.WriteFile(`stdlib.go`, []byte(out), 0644); err != nil {
		log.Fatal(err)
	}
}
